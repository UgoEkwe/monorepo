// Database client wrapper for AI workspace with optional dependency handling
import { safeImport, featureFlags, createFallbackProxy } from '@modular-ai-scaffold/core/utils/optional-deps';

// Conditional import for Prisma client
const prismaClient = safeImport('@prisma/client');

// Create a singleton Prisma client instance for the AI workspace
const createPrismaClient = () => {
  // Check if database is enabled via feature flag
  if (!featureFlags.isEnabled('database')) {
    console.info('[AI] Database disabled via feature flag, using fallback client');
    return createFallbackDatabaseClient();
  }

  // Check if Prisma client is available
  if (!prismaClient.available || !prismaClient.module) {
    console.warn('[AI] Prisma client not available, using fallback client');
    return createFallbackDatabaseClient();
  }

  // Check environment variables
  if (!process.env.DATABASE_URL) {
    console.warn('[AI] DATABASE_URL not configured, using fallback client');
    return createFallbackDatabaseClient();
  }

  try {
    const { PrismaClient } = prismaClient.module;
    return new PrismaClient({
      log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
      errorFormat: 'pretty',
    });
  } catch (error) {
    console.error('[AI] Failed to create Prisma client:', error);
    return createFallbackDatabaseClient();
  }
};

// Fallback database client for when Prisma is not available
const createFallbackDatabaseClient = () => {
  const isDevMode = process.env.NODE_ENV === 'development';
  
  // Create demo data for development mode
  const demoUsers = [
    { id: 'demo-user-1', email: 'demo@example.com', name: 'Demo User', metadata: { role: 'demo' } }
  ];
  
  const demoProjects = [
    { 
      id: 'demo-project-1', 
      name: 'AI Demo Project', 
      description: 'A demo project showcasing AI capabilities',
      slug: 'ai-demo-project',
      ownerId: 'demo-user-1',
      metadata: { type: 'demo', features: ['ai-generation'] }
    }
  ];
  
  const demoEntities = [
    {
      id: 'demo-entity-1',
      name: 'Demo AI Generated Content',
      description: 'This is demo content generated by the AI workspace',
      status: 'published',
      projectId: 'demo-project-1',
      metadata: { type: 'ai-generated', model: 'demo-model' },
      createdAt: new Date(),
      updatedAt: new Date()
    }
  ];

  return {
    user: {
      findFirst: async (query?: any) => {
        if (isDevMode) {
          console.info('[AI Fallback] user.findFirst() - returning demo user');
          return demoUsers[0] || null;
        }
        return null;
      },
      create: async (data: any) => {
        if (isDevMode) {
          console.info('[AI Fallback] user.create() - simulating user creation');
          const newUser = { id: `demo-user-${Date.now()}`, ...data.data };
          demoUsers.push(newUser);
          return newUser;
        }
        throw new Error('Database not configured');
      }
    },
    
    project: {
      findFirst: async (query?: any) => {
        if (isDevMode) {
          console.info('[AI Fallback] project.findFirst() - returning demo project');
          return demoProjects[0] || null;
        }
        return null;
      },
      create: async (data: any) => {
        if (isDevMode) {
          console.info('[AI Fallback] project.create() - simulating project creation');
          const newProject = { id: `demo-project-${Date.now()}`, ...data.data };
          demoProjects.push(newProject);
          return newProject;
        }
        throw new Error('Database not configured');
      }
    },
    
    entity: {
      findMany: async (query?: any) => {
        if (isDevMode) {
          console.info('[AI Fallback] entity.findMany() - returning demo entities');
          return demoEntities;
        }
        return [];
      },
      create: async (data: any) => {
        if (isDevMode) {
          console.info('[AI Fallback] entity.create() - simulating entity creation');
          const newEntity = { 
            id: `demo-entity-${Date.now()}`, 
            createdAt: new Date(),
            updatedAt: new Date(),
            ...data.data 
          };
          demoEntities.push(newEntity);
          return newEntity;
        }
        throw new Error('Database not configured');
      }
    },
    
    // Add other model proxies as needed
    $disconnect: async () => {
      console.info('[AI Fallback] Database disconnect - no-op');
    }
  };
};

export const prisma = createPrismaClient();

// Note: Do not re-export model types here to keep this workspace buildable
// without requiring Prisma schema generation. Use local interfaces instead.